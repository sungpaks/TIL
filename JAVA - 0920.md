- 객체 클래스의 멤버 변수 - 인스턴스 변수 or 객체 변수

- primitive type : 변수를 선언하면 그대로 메모리가 잡힌다
	`int a` , 또는 배열도 : `new int[10]` 이러면 10개 int 메모리가 모두 잡힌다
- 객체 클래스 : 변수를 선언하면 "레퍼런스"가 생긴다 - 메모리는 잡히지 않음
	생성을 해야 잡힌다 : `new myRect[10]` 이러면 레퍼런스만 10개 생긴거고, 실제 메모리가 잡히려면 객체를 생성해야함 => 인스턴스화

- 함수에 인자를 전달 => 값 or 레퍼런스 ??
	- primitive 변수는 **값** 자체로 넘겨진다
	- 객체나 배열은 **레퍼런스로** 넘겨진다
		- 따라서 객체 자체를 swap함수로 바꾸고자 할 때는 정말 객체변수를 모두 바꿔줘야 함.. 그냥 바꾸면 함수 내에서 가리키는 대상이 바뀌는 것일 뿐이다.
		- 객체에 대해서는 `name = new String(in.name)` 과 같이, 복사생성자를 불러야
		- 근데 String에 한해 `name = in.name` 와 같이 직접할당 (대입연산자 오버로딩) 가능
- Java는 default 파라미터 없음
- 소멸자가 없음 : JAVA는 new만 있고 delete는 없다 => 메모리 해제는 직접 X, JVM에서 카비지컬렉션을 시행함
- **접근지정자**  : 폐쇄적인 순으로 나열 : 
	1. private : 숨긴다, 나만 본다
	2. default : 나, 그리고 패키지까지
	3. protected : 나, 패키지, 그리고 다른 패키지라도 내 자식이면 볼 수 있다
	4. public : 누구든 접근 가능
	inner class도 접근지정 가능
- **static** : 정적. (dynamic : 프로그램이 돌면서 결정 / static : 프로그램이 돌기 전에 결정)
	- 멤버 변수를 static으로 생성하는 경우 : `static int w_max = 100;` 객체를 생성하지 않아도 이미 존재한다
	- static 멤버 변수는 클래스 이름을 통해 접근할 수 있다 (이미 존재하므로) :  `myRect.w_max`  => 메모리가 객체에 종속되지 않고, 클래스에 종속된다 
	- static 함수도 비슷.
		- main이 static 인 것도 객체에 종속되지 않고 "그냥" 존재하기 위함
	- 주의 : static함수에서는 instance변수를 사용할 수 없음 : 객체가 생성되기 전 타이밍임
		또한 당연히도, this() 또한 불가
		