`#include <thread>`
`thread myThread(함수포인터, 객체, 인자, 인자, ... )`
예를들어, `pc.dig(targetPos.X, targetPos.Y)`를 스레드로 대체하려면
=> `thread digThread(&PC::dig, &pc, targetPos.X, targetPos.Y);`
이런 다음, 두 가지 선택지
- `myThread.join()` : 메인스레드는 저거 끝나기를 기다린다
- `myThread.detach()` : 메인스레드와 분리시켜 백그라운드 작업을 지속
나의 목적은 백그라운드에서 작업이 일어나고, 다른 동작들은 계속되게 하고싶으므로, `detach()`로 한다

주의 : `switch case`문 안에서 thread변수를 만들면 `thread 초기화가 case레이블에 의해 생략되었습니다.` 뭐 이런게 나온다 
=> case문 내부에서 변수를 선언할 때 발생하는데, case 다음 실행할 구문(변수 선언 포함해서)을 {}스코프로 묶으면 된다..

함수 인자가 있을 때, 없을 때, 어떤 객체에서 부르는 함수일 때, namespace 등등에 주의



---

C++로 게임을 만들고 있는데요
사실 사용중인 이미지 렌더링 라이브러리가 C로 작성되어있었어서
시작은 C였고 멀티스레딩은 생각을 해두지 않았었습니다
그럼 이제 문제가 뭐냐 모든 동작이 순차적이라는 것인데요

예를 들어 가장 문제점은
게임에서는 땅을 파는 함수가 있는데
이 함수에서는 진동 모션과 블록의 파괴 등까지 해서 한 동작에 렌더링이 최소 5번 일어납니다
이 진동 모션이야말로 주범인데
![](https://i.imgur.com/05czAG6.png)
앞뒤로 왔다갔다를 보여줘야 하니 렌더링이 다다닥 있습니다
맥북을 쓰는 팀원분은 렌더링이 빨라서 체감이 크지 않는데
제 윈트북은 개느려서 이 렌더링 세 번에 걸리는 시간이 상당히 크고 그동안 다른 동작에 도달하지 못하니 NPC들은 멈춰있고 그렇습니다

그래서 이 땅 파는 함수 `dig`을 다른 스레드에서 실행하고자 했습니다
먼저 그러려면 `#include <thread>`로 스레드 헤더를 가져옵니다
이제 스레드 객체를 `thread myThread(함수포인터, 객체, 인자, 인자, ... )`와 같이 생성해줍니다.
예를 들어, 제 경우 `pc.dig(x, y);`에 대한 스레드 객체를 생성하기 위해
`thread digThread(&PC::dig, &pc, x, y);` 이렇게 작성했습니다
이제 두 가지 선택지가 있는데
- `myThread.join()` : 메인스레드는 저거 끝나기를 기다림
- `myThread.detach()` : 메인스레드와 분리시켜 백그라운드 작업을 시키고, 메인스레드는 할 일 하러 간다
메인스레드는 계속 일하고 `dig`만 따로 실행하면 좋겠으니, `detach`합니다

주의해야 할 점이 있었는데
`switch`의 `case`문 내에서 thread 변수를 만드니까 `thread 초기화가 case레이블에 의해 생략되었습니다.` 뭐 이런 에러가 발생합니다
`case`문 내부에서 변수를 선언한게 문제인데, 
- `switch`시작 전에 변수 선언하거나
- `case`문을 중괄호 `{}`로 묶거나
둘 중 하나 선택해서 해결할 수 있습니다
대신 후자의 방식은 당연히 scope가 중괄호 내부로 제한되니 그 안에서만 사용할 수 있습니다
![](https://i.imgur.com/MuWI0wV.png)

스레드 동기화
![](https://i.imgur.com/cSbhn7L.png)
이렇게 여러 개의 스레드가 돌아갈 떄 