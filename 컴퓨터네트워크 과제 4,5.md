<div style="text-align: right; font-weight: bold">19010418 조성훈</div>

# 4장 
## P8
***a.*** Longest Prefix Matching 사용, 5개의 엔트리로 구성된 forwarding table

| Destination Address Range | Link Interface |
| ---------- | ---------- |
| `11100000 00****** ******** ********` | 0 |
| `11100000 01000000 ******** ********` | 1 |
| `1110000* ******** ******** ********` | 2 |
| `11100001 1******* ******** ********` | 3 |
| `otherwise` | 3 |

***b.*** 
- `11001000 10010001 01010001 01010101` => **3번** Link interface
	매칭되는 Longest Prefix가 없으므로 5번째 rule에 의해 3번
- `11100001 01000000 11000011 00111100` => **2번** Link interface
	3번째 rule인 `1110000* ******** ******** ********`와 매칭
- `11100001 10000000 00010001 01110111` => **3번** Link interface
	4번째 rule인 `11100001 1******* ******** ********`와 매칭


## P11
- Subnet 1 : 60개 이상 => 64 = $2^6$ => prefix 제외하고 6비트 이상 필요
- Subnet 2 : 90개 이상 => 128 = $2^7$ => prefix 제외하고 7비트 이상 필요
- Subnet 3 : 12개 이상 => 16 = $2^4$ => prefix 제외하고 4비트 이상 필요

이 때, 세 라우터들의 공통 서브넷 prefix는 `223.1.17/24`
=> 따라서, 아래와 같이 서브넷을 분할하면 조건을 만족할 수 있다 :

Subnet 1 : `223.1.17.0/26` 
Subnet 2 : `223.1.17.128/25`
Subnet 3 : `223.1.17.192/28`


## P15
***a.*** 
- A : 최소 250개 이상의 인터페이스 => 256=$2^8$ 8비트 이상 필요
- B : 최소 120개 이상 => 128 = $2^7$ 7비트 이상 필요
- C : 최소 120개 이상 => 128 = $2^7$ 7비트 이상 필요
- D,E,F : 2개 인터페이스 => 각 최소 1비트 이상 필요

`214.97.254/23`의 공통 prefix를 가지면서 위 조건을 만족하도록 분배하면

A : `214.97.255/24` : 8비트 전체를 사용하므로 최대 256개 인터페이스
B : `214.97.254.0/25 - 214.97.254.0/29` :  최대 $2^7 - 2^3$ = 120개 인터페이스
C : `214.97.254.128/25` 7비트 전체 사용하므로 최대 128개 인터페이스
D,E,F는 위에서 B의 prefix를 할당하고 때 남았던 3비트중에서 할당한다 :
D : `214.97.254.0/31` : 1비트 = 2개 인터페이스
E : `214.97.254.2/31` : 1비트 = 2개 인터페이스
F : `214.97.254.4/30` : 남은 2비트 =  4개의 인터페이스

***b.*** 
Router 1 : A,D,F

| Destination Address Range | Link |
| ---- | ---- |
| `11000000 01100001 11111111 ********` | A |
| `11000000 01100001 11111110 0000000*` | D |
| `11000000 01100001 11111110 000001**` | F |

Router 2 : B,D,E

| Destination Address Range | Link |
| ---- | ---- |
| `11000000 01100001 11111110 0*******` | B |
| `11000000 01100001 11111110 0000000*` | D |
| `11000000 01100001 11111110 0000001*` | E |

Router 3 : C,E,F

| Destination Address Range | Link |
| ---- | ---- |
| `11000000 01100001 11111110 1*******` | C |
| `11000000 01100001 11111110 0000001*` | E |
| `11000000 01100001 11111110 000001**` | F |


## P17
5,000,000 byte를 데이터그램 크기로 나누어 개수를 구하되, 
각 데이터그램은 헤더 포함 1,500 byte이므로, IP헤더의 크기를 제외하면 각 데이터그램의 데이터필드는 1480 byte가 된다.
이 때, 5,000,000 byte의 MP3파일은 데이터그램이라고 나와있지 않으므로,
5,000,000 byte의 데이터를 최대 1480 byte씩 단편화한다
$1480 * 3378 = 4999440$ 이므로,
**1480 byte씩 3378개, 나머지인 560 byte 1개로 분리**할 수 있다.
이제 각 데이터들에 20-byte IP header를 추가하여 데이터그램으로 만들면,
**1500 byte의 데이터그램 3378개, 580 byte의 데이터그램 1개로 단편화**(fragmentation)된다.



# 5장
## P3 & P8
![](https://i.imgur.com/HIuQj0u.png)


## P14
***a.*** **eBGP**  : AS4에서 AS3에게 `prefix x`를 advertise
***b.*** **iBGP** : AS3 내에서, 다른 내부의 라우터들에게 `prefix x`를 advertise
***c.*** **eBGP** : AS3에서 AS1에게 `prefix x`를 advertise
***d.*** **iBGP** : AS1 내에서, 다른 내부 라우터들에게 `prefix x`를 advertise
