<div style="text-align : center; font-weight : bold; font-size : 56px">JAVA 과제 4&5</div>
<div style="text-align : right">19010418조성훈</div>

## 1. 타이틀 화면 / 게임 화면 / 게임오버 화면

가장 먼저, 게임에서 요구되는 세 가지 화면을 각각 다른 클래스로 유지하려면 세 가지 종류의 `JPanel`을 구성해야 했고, 이 세 가지 `JPanel`들을 조건에 따라 갈아 끼우는 동작을 어떻게 구현할지 고민해야 했습니다.
먼저, 패널을 갈아 끼워야 하는 조건은 다음과 같았습니다
- 모든 패널은 **SPACE BAR** 입력 시 다음 패널(다음 화면)으로 이동
- 특별히, 게임 화면 패널은 GameOver의 조건이 충족되면 다음 패널로 이동
- 게임오버 화면 다음에 오는 화면은 타이틀 화면으로, 이는 즉 프로그램을 닫기 전까지는 세 가지 화면이 무한반복됨을 의미합니다.

제가 구현한 방식은 다음과 같습니다.
- Frame : 먼저 `Frame`이 `Runnable`인터페이스를 구현하도록 하고, main 스레드는 새로운 스레드를 생성하고 이 새로운 스레드에게 "세 가지 패널을 무한으로 갈아끼우는 동작"을 맡깁니다. 이후 main 스레드는 새로 생성된 스레드와 `join`하여 대기합니다.
- Frame에서 스레드 생성 : 이제, 새로 생성된 스레드는 현재 장면에 해당하는 패널을 꽂습니다(`add`). 각 패널은 각자의 작업을 수행하는 스레드를 각자 가지고 생성과 동시에 `start`를 호출하므로, 여기에서는 패널을 생성하고 `join`하여 패널의 스레드의 종료를 기다립니다.
- `GamePanel`(부모) : 각 패널은 추상형 부모클래스인 `GamePanel`을 상속하도록 하며, 이 부모클래스에서는 다음과 같은 공통 동작들을 정의합니다 : 
	- `Runnable` 인터페이스 구현: 기본 생성자에서 스레드를 생성하고 시작
	- `KeyEvent` 인터페이스 구현
	- `paintComponent` : 각 패널들은 공통된 그라데이션 배경을 가집니다.
- `GameStartPanel` & `GameOverPanel` : 게임 타이틀 화면과 게임오버 화면에 해당하는 자식 패널입니다.
	- `flickerThread`를 람다식으로 생성하여, 텍스트의 깜빡임 동작 구현
	- `run` : 패널의 주 스레드는 `wait`으로 대기하며, 
	- **SPACEBAR**입력 시 `notify`하여 `wait`상태를 종료
- `GamePlayPanel` : 본격적인 벽돌깨기 게임의 동작을 가지며, `run`함수는 기본적으로 Game-Loop 형태입니다. (update-resolve-render)

이렇게 하여 각 Frame과 Panel, 각 Panel간의 화면 전환을 살펴보았습니다. 이제 `GamePlayPanel`의 벽돌깨기 게임 구현을 살펴보기 전에, 벽돌과 라켓, 공 등의 Object들에 대해 먼저 다루겠습니다.

## 2. Objects

벽돌깨기 게임 진행 시 등장하는 라켓(실제 클래스 명칭은 `MyPlate` : 플레이어가 조작하는 직사각형) , 벽돌, 벽, 공 등의 물체들은 아래 구조도와 같은 계층적인 상속구조를 가집니다. 
![](https://i.imgur.com/fa4IEfa.png)

모든 물체들은 `MyObject`라는 공통 조상 클래스로 묶여 한번에 관리될 수 있으며, 공통 특징에 따라 계층적인 상속구조를 가짐으로써 더 작은 단위로도 그룹화되어 관리될 수 있습니다.
또한 새로운 클래스를 추가할 때에도, 추가하고자 하는 클래스가 어떤 특징을 가지게 될지 조금만 고민한다면 이미 존재하는 클래스를 상속하여 조금의 조미료만 첨가하면 되므로 확장성이 용이합니다.
- `MyBrick` : 공과 부딪히면 사라지는 **블록**입니다.
	- `MyWall` : 게임의 좌,우,상단 경계를 담당할 **벽**으로, 벽돌이지만 *사라지지 않는* 벽돌인 셈입니다.
	- `MyPlate` : 유저가 조작하는 **라켓**으로, 벽돌이지만 *사라지지 않고 움직일 수 있는* 벽돌인 셈입니다.
	- `MySpecialBrick, MyBlueBrick, MyRedBrick` : **특수한 블록**으로, 기본 블록보다 살짝 확장되는 파생형 블록입니다.
- `MyBall` : 블록 종류와 부딪히면 튕겨나가는 **공**입니다.
	- `MyItem` 종류 : **아이템**으로, 아래로만 낙하하며 라켓과 충돌하면 특별한 반응을 하는, *특수한 공*으로 취급됩니다. `MyBlueBrick`이 파괴되면 좋은 아이템이,  `MyRedBrick`이 파괴되면 나쁜 아이템이 생성됩니다.

## 3. Game Play

본격적인 벽돌깨기 게임은 `GamePlayPanel`에서 진행됩니다. 
먼저 주어진 과제의 요구사항과 예시 파일을 면밀히 살피며 최대한 비슷한 게임을 구현하는 것을 중점으로 삼았습니다.
그 후에는 게임을 더 재밌게 만들 요소들을 추가하고, 이미지와 사운드를 적절히 사용하여 완성도를 높이고자 하였습니다.

### 3-1. Game Loop

`GamePlayPanel`에서는 스레드가 *update->resolve->render* 의 과정, 즉 ***GAME-LOOP***를 반복하며 게임이 진행됩니다. 
- *update* : 공과 라켓(라켓은 키보드 좌,우를 누른 경우에만)의 위치를 각 객체의 속도에 따라 변화시킵니다.
- *resolve* : 변화된 공과 라켓의 위치에 따른 적절한 반응을 처리합니다. 예를 들어, 공이 벽돌과 충돌 시 공의 속도가 변하며, 벽돌은 깨진 상태로 변하여 그라데이션으로 사라지거나, 공이 바닥으로 떨어지면 공이 사라지는 등의 동작입니다.
- *render* : `repaint`로 변경사항들을 다시 그립니다.
- 또한 화면 상의 모든 벽돌이 깨졌다면 다음 스테이지로 넘어가거나, 모든 공이 바닥으로 떨어졌다면 게임오버가 되거나, 등을 확인하고 처리합니다.

이 과정을 위해, 물체들의 객체들은 업캐스팅되어 한번에 관리하게 됩니다.
그러나 이 때, 전체를 `MyObject`로 묶어 정말로 "한번에" 관리하기보다는 `MyBrick`과 `MyBall`을 나누어 관리하는 방법을 선택했습니다.
그 이유는 `MyBrick`과 `MyBall`의 동작은 상당히 다르고 단순히 `update`와 `resolve`로 끝나지 않기 때문입니다. 이 둘 사이의 상호관계성을 효율적으로 관리하려면 분리하여 관리하는 것이 합리적인 선택이라고 생각했습니다.

### 3-2. Stage Level & 점수

게임은 3x3의 벽돌로 시작합니다. 화면의 벽돌을 모두 파괴하면 1초 가량 멈춘 뒤 다음 스테이지로 넘어갑니다. 스테이지가 증가하면 벽돌의 밀도 또한 증가하며, i번째 스테이지에서는 $3i$X$3i$ 개의 벽돌이 생성됩니다.
또한 스테이지를 넘어가게 되면, 아이템으로 얻은 효과들이 반감(정상치와 현재 수치의 평균값으로 조정)되며, 공들의 속도가 조금씩 빨라집니다. 

벽돌을 깨면 개당 점수가 10씩 증가합니다. 이 점수는 패널을 넘나들며 수정&접근&유지되어야 하므로, 패널의 부모클래스인 `GamePanel`에 `static`으로 점수 정보를 저장하여 전역적으로 관리되도록 작성하였습니다.

### 3-3. 특별한 블록

게임에 존재하는 특별 블록은 세 가지입니다.
- 노란색 블록 `MySpecialBrick` : 과제에서 기본적으로 요구되었던 공을 3개로 분열시키는 블록입니다.
	- 공이 해당 블록에 부딪히고 반사되는 순간, 그 방향에서 -30도, +30도 각도로 두 개의 공을 더 생성하게 됩니다. 적당한 `cos, sin`함수를 사용하여 이를 구현할 수 있습니다.
	- 이 때, 새로운 `MyBall` 객체를 생성하고 `LinkedList`에 새 객체를 추가하게 되는데, 이 동작은 필연적으로 반복문으로 (`MyBall`의)`LinkedList`를 순회할 때 일어납니다. 따라서 리스트에서 객체를 삭제할 때와 비슷하게 `iterator`를 이용해야 하는데, `LinkedList`의 `iterator`에 `add`메소드가 존재하지 않는 문제가 있었습니다.
	- 이를 해결하기 위해, 리스트의 순회를 시작하기 전에 `newBalls`라는 새 `LinkedList`를 생성하고, 새로운 객체는 여기에 추가한 뒤, 순회가 끝나면 `addAll`메소드를 이용하여 원본 `LinkedList`에 새 객체들을 모두 추가해주도록 하였습니다.
- 파란색 블록 `MyBlueBrick` : 파괴하면 좋은 아이템 두 종류 중 하나를 랜덤으로 생성합니다.
- 빨간색 블록 `MyRedBrick` : 파괴하면 나쁜 아이템 두 종류 중 하나를 랜덤으로 생성합니다.

### 3-3. 라켓

라켓은 유저가 직접 조작하므로 사용자 경험에 가장 밀접한 물체 중 하나입니다. 따라서 라켓의 구현에 있어 다양한 디테일들을 고려해야 했습니다.
- 라켓의 움직임 : 라켓은 키보드 좌, 우 입력으로 움직입니다. 그러나, `keyPressed`의 입력에 대응하여 라켓의 이동을 호출하도록 하면 버튼을 꾹 누를 때의 움직임(특히 방향전환)이 부드럽지 않습니다. 
	따라서 이를 해결하고 움직임을 부드럽게 하기 위해서는, `VK_LEFT`와 `VK_RIGHT`에 대응하는 플래그를 만들고 `keyPressed`와 `keyReleased`시 해당하는 플래그들을 켜고 끄도록 처리합니다.
	이후 실제 라켓의 이동은 Game-Loop에서 처리합니다. 두 플래그의 on/off에 따라 방향을 정하고, `update`를 호출합니다.
- 라켓과 공의 충돌 : 공이 라켓에 부딪히면 튕겨나오는 각도는 여타 물체들과 다릅니다. 다른 물체들과 똑같이 그저 입사각과 반사각이 같도록 설정하면 게임이 단조로워질 것입니다.
	따라서, 라켓의 중심을 기준으로 공이 부딪힌 지점까지의 각도를 계산하고, 이 각도에 따라 공이 반사되도록 충돌을 구현합니다. 

### 3-4. 아이템

아이템은 기존 과제 요구사항에 없는 완전히 새로운 요소입니다. 아이템은 라켓의 속도 감소/증가, 라켓의 폭 감소/증가 이렇게 네 가지로 구성됩니다. 각 아이템은 위에서 언급된 대로 빨간/파란 블록을 파괴 시 생성됩니다.
- 아이템은 생성 시 랜덤한 속도로 낙하합니다. `MyBall`을 상속하여 아이템 클래스가 만들어지므로, x축 이동속도를 0으로, y축 이동속도를 랜덤한 상수로 설정하기만 하면 됩니다.
- 아이템은 라켓 외 다른 블록들과 충돌하지 않습니다. 다만 라켓과 충돌하면 아이템 효과를 라켓에 부여합니다.
- 아이템의 효과는 아이템이 라켓에 닿으면 `ItemEffect` 인터페이스의 메소드를 호출함으로써 적용됩니다. 추상클래스인 `MyItem`은 `ItemEffect`를 구현하므로, `MyItem`을 상속하는 구체화된 아이템 클래스라면 응당 아이템 효과인 `ItemEffect`를 구현해야만 합니다.
- 아이템은 `drawOval`로 구형을 그리던 `MyBall`과 다르게 각 효과에 맞는 이미지를 이용합니다. 이렇게 이미지를 띄우기 위해서는 매번 `URL`을 열고 `BufferedImage`에 읽어오는 등의 과정이 필요합니다. 이는 아이템이라면 반드시 거치는 과정이지만, 각 아이템마다 다른 점은 단지 이미지 파일의 파일명이 다를 뿐입니다. 
	따라서, `MyItem` 부모생성자는 자식클래스로부터 반드시 *파일 명*을 인자로 받도록 하고, 이미지 세팅과 그리기 등은 모두 부모에서 수행하도록 캡슐화합니다.

## 4. 사운드

게임 내 사운드로는 각 화면 별 배경음악(이하 BGM)과, 게임 플레이 시 공이 튕길 때 나는 효과음이 존재합니다. 

위에서 이미지에 대해 언급한 것과 같이, 사운드 또한 `Clip`을 세팅하는 과정은 동일하고 경로의 파일명만이 다릅니다. 따라서, BGM의 경우는 `GamePanel`에, 효과음의 경우는 `MyObject`에 그 과정을 작성하고 자식으로부터 파일명만을 전달받아 이에 해당하는 `Clip`을 세팅하도록 캡슐화합니다.
- BGM : `GamePanel`에서 세팅과 동시에 `loop`로 재생하여 지속적으로 재생합니다.  `Clip`을 `start`하면 새로운 스레드가 시작하는 것이므로 패널 전환 시 BGM종료에 유의합니다.
- 효과음 : `MyBrick`, `MyPlate` 등 효과음을 가지게 할 물체의 생성자에서 `setClip`를 호출해두고, `MyBall`이 충돌할 때 이를 재생하도록 합니다.

## 5. 스레드 동기화

이번 과제에서는 스레드가 굉장히 많이 쓰였습니다. 멀티스레딩에 의한 편의와 그로 인한 무궁무진함을 경험할 기회였지만, 동시에 멀티스레딩으로 인해 새로운 문제들에 직면하게 되었습니다.

특히 게임 플레이 시, `run` 등 스레드와 밀접하게 관련되어 있는 함수에서는 리스트의 순회와 객체 수정, 객체 삭제, 객체 추가 등이 빈번하고 또한 동시에 일어나므로, 이로 인한 예상치 못한 문제가 발생할 수 있습니다.

그렇다고 무턱대고 함수들을 `synchronized`로 선언하고 묶어서 동기화한다면 스레드들의 동작이 느려지고 결국에는 멀티스레딩에 의한 이점을 활용하지 못할 수 있습니다.

따라서, 리스트 순회나 객체 추가/삭제 등 문제가 생길 수 있는 곳에만 부분적으로 `synchronized`블록을 선언하여 적절한 정도로만 동기화하고자 하였습니다.

또한 코드를 부주의하게 작성한다면 스레드가 접근하는 자원의 객체가 실제로 생성되기 전에 스레드가 먼저 시작하는 일이 발생할 수 있으므로, 이에 대해서도 주의를 기울여야 했습니다.



## 정리

이번 과제를 통해 계층적인 상속, 이를 통한 클래스의 구조화, 계층 또는 클래스 간의 캡슐화, 각기 다른 자식클래스들의 다형성, 인터페이스를 통한 다능화 등 여러가지 객체지향적 특성을 활용해볼 수 있었습니다. 

또한 멀티스레딩 활용에 의한 가능성과 효율성을 실감하면서도, 그로 인한 문제점을 실제로 마주하고 대처하며 멀티스레딩 프로그래밍에 한 걸음 더 가까워질 수 있었습니다.

또한 코드를 작성하며 여러 디자인 패턴의 필요성과 효용성에 대해 깨달을 수 있었고, 교수님께서 마지막에 말씀하셨던 것처럼 디자인 패턴에 대해 공부를 좀 더 해봐야겠다는 생각을 하게 되었습니다.

이상 마치겠습니다. 감사합니다. 