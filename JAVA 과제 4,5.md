일단 패널을 조건에 따라 갈아끼워야하는데
Game Start와 Game Over는 키 리스너로 SPACE입력이 들어오면 갈아끼운다
Game Play는 게임 종료 조건이 되면 갈아끼운다
그래서 이걸 어떻게 하냐

- 일단 Frame에서도 Runnable을 구현해서 스레드를 만들 수 있게 한다
- 이 Frame객체에서 메인스레드는 새 Thread를 생성하고, 이 Thread에게 지금 차례의 패널을 생성하고 Frame에 끼운다
- Main스레드는 이 Thread와 join하여 계속 기다린다. 사실상 프로그램 닫을 때까지 기다림이 끝나지 않음
- 패널을 꽂고 갈아끼우는 Thread는 현재 차례의 패널을 생성 -> 끼운다 -> 포커스 넘긴다 -> `setVisible` -> 해당 패널 안쪽의 스레드를 기다린다.
- 패널 내부의 스레드의 run : 
	- GameStart와 Over는 KeyEvent로 Space가 눌릴 때까지 wait(), 눌리면 notify => 스레드가 끝난다
	- GamePlay는 게임종료까지 계속 Game Loop를 돈다
- 패널의 스레드가 끝나면 다음 패널을 갈아끼울 차례이므로, 현재 Scene을 넘기고 run을 재귀호출한다


plate가 방향 바꿀 때, 움직이기 시작할 때 멈춤 없이 바로 부드럽게 움직이게 하는 법?
- `isMoving`을 boolean으로 하는 방법도, int로 하는 방법도 아님
- 왼쪽 눌렸는지에 대한 `boolean`과 오른쪽 눌렸는지에 대한 `boolean`을 유지한다. 
- 왼쪽만 눌려있으면 왼쪽으로 방향을 설정하고 업데이트
- 오른쪽만 눌려있으면 오른쪽으로 방향 설정하고 업데이트
- 둘 다 눌려있으면 vx=0으로 업데이트
- press하면 왼쪽or오른쪽인지 봐서 플래그 turn on
- release하면 왼쪽or오른쪽인지 봐소 플래그 turn off


~~`plate`상속해서 `brick`되게했는데, 반대로 하는게 좋으려나?? 바꿔보자
지금 공이 한번 튀기고나면 벽을 한번 통과하는 버그가 있음~~


폭은 750으로 하자.. 처음 250,250,250일거고, 그다음 


스테이지의 레벨에 따라, 
1레벨 = 벽돌 3x3
2레벨 = 벽돌 6x6
3레벨 = 벽돌 9x9
4레벨 = 벽돌 12x12 ..

이미지 늑대와 아기돼지 써서 늑대가 벽돌깨는 컨셉 ㄱㄱ? ㅋㅋ

헉ㅋㅋㅋ iterator순회할때도 "iterator"에 add해야함!! 
직접 linkedList에 add하거나 remove하면 바로 concurrentException
아 근데 iterator에 add메서드가 없다
- 벽돌과 공을 resolve할 때, 새로 생기는 ball들은 newBalls에 담는다, foreach문이 전부 끝나고나서 balls에 newBalls를 추가한다.

공의 속도는 점점 높아짐

start는 마지막에 하도록 변경

fadeOut을 어떻게 하는게 가장 좋을까?
- fade상태를 따로 유지하고, 깨지면 setDead가 아니라 `isFade=true`로 하고, 점차fade하기
- 스레드를 빼서 잔상남기기
***근데 필드 선언에서 `boolean isDead = false` 이렇게 하는거랑, 그냥 두고 생성자에서 `isDead = false`하는거랑 머가다름?***


점수 : gamePanel에 static으로 유지하고 start생성 시 초기화
play에서도 over에서도 써야함

그림자는 똑같은 검은색 텍스트 만들어서 깔기

벽돌 사이 간격 추가 (생성자에서 w, h에 -10씩)



---


## 1. 타이틀 화면 / 게임 화면 / 게임오버 화면

가장 먼저, 게임에서 요구되는 세 가지 화면을 각각 다른 클래스로 유지하려면 세 가지 종류의 `JPanel`을 구성해야 했고, 이 세 가지 `JPanel`들을 조건에 따라 갈아 끼우는 동작을 어떻게 구현할지 고민해야 했습니다.
먼저, 패널을 갈아 끼워야 하는 조건은 다음과 같았습니다
- 모든 패널은 **SPACE BAR** 입력 시 다음 패널(다음 화면)으로 이동
- 특별히, 게임 화면 패널은 GameOver의 조건이 충족되면 다음 패널로 이동
- 게임오버 화면 다음에 오는 화면은 타이틀 화면으로, 이는 즉 프로그램을 닫기 전까지는 세 가지 화면이 무한반복됨을 의미합니다.

제가 구현한 방식은 다음과 같습니다.
- Frame : 먼저 `Frame`이 `Runnable`인터페이스를 구현하도록 하고, main 스레드는 새로운 스레드를 생성하고 이 새로운 스레드에게 "세 가지 패널을 무한으로 갈아끼우는 동작"을 맡깁니다. 이후 main 스레드는 새로 생성된 스레드와 `join`하여 대기합니다.
- Frame에서 스레드 생성 : 이제, 새로 생성된 스레드는 현재 장면에 해당하는 패널을 꽂습니다(`add`). 각 패널은 각자의 작업을 수행하는 스레드를 각자 가지고 생성과 동시에 `start`를 호출하므로, 여기에서는 패널을 생성하고 `join`하여 패널의 스레드의 종료를 기다립니다. 그 후에는 다음 장면의 패널이 반복적으로 갈아 끼워져야 하므로, `run`함수를 재귀호출합니다.
- `GamePanel`(부모) : 각 패널은 추상형 부모클래스인 `GamePanel`을 상속하도록 하며, 이 부모클래스에서는 다음과 같은 공통 동작들을 정의합니다 : 
	- `Runnable` 인터페이스 구현: 기본 생성자에서 스레드를 생성하고 시작
	- `KeyEvent` 인터페이스 구현
	- 점수 정보 저장 : 점수 정보는 각기 다른 자식패널에서 접근&수정될 필요가 있으므로, `static`으로 유지합니다.
	- `paintComponent` : 각 패널들은 공통된 그라데이션 배경을 가집니다.
	- 그 외 getter, setter 메소드, 스레드를 깨우는 메소드, `JLabel`의 그림자를 생성하는 메소드 등
- `GameStartPanel` : 게임 타이틀 화면에 해당하는 자식 패널입니다.
	- 예시 파일을 참고하여 적당한 텍스트의 `JLabel` 추가
	- `flickerThread`를 람다식으로 생성하여, 텍스트의 깜빡임 동작 구현
	- `run` : 패널의 주 스레드는 **SPACEBAR**입력이 들어올 때까지 대기하므로, `wait`으로 대기합니다.
	- Key 입력 : **SPACEBAR**입력 시 `notify`로 `wait`상태를 종료하고, `flickerThread`를 종료하도록 합니다.
- `GameOverPanel` : 게임 오버 화면에 해당하는 자식 패널입니다.
	- `GameStartPanel`과 거의 비슷한 동작을 가집니다.
	- 깜빡임 주기, 점수 출력 등 사소한 부분만이 다릅니다.
- `GamePlayPanel` : 본격적인 벽돌깨기 게임의 동작을 가집니다.

이렇게 하여 각 Frame과 Panel, 각 Panel간의 화면 전환을 살펴보았습니다. 이제 `GamePlayPanel`의 벽돌깨기 게임 구현을 살펴보기 전에, 벽돌과 라켓, 공 등의 Object들에 대해 먼저 다루겠습니다.

## 2. Objects

