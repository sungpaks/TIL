<div style="text-align: right; font-weight: bold">19010418 조성훈</div>

주어진 **Requirements**에 대한 구현 아이디어는 다음과 같습니다.
- 여러 종류의 도형 구현과 관리 : 도형은 하나의 부모클래스로부터 상속받고 `java.util.LinkedList`에 각 도형을 업캐스팅하여 관리합니다. 
	이 때, 그린 순서에 따라 그리려면, 각 도형 객체는 `LinkedList`의 뒤에서부터 넣고, 앞에서부터 그립니다.
- 색상 : JColorChooser객체의 기능을 이용하여 색상 선택 버튼을 구현합니다.
- 선택 기능 구현 : 각 도형 클래스에 선택 여부 판단 메소드를 작성하고, 마우스 클릭 이벤트에서 이를 사용해 판별합니다.
	선택되었다는 표시인 빨간 테두리 : 직선과 곡선은 더 두꺼운 선으로 한번 더 그립니다. 직사각형과 원은 테두리의 색만 바꿉니다.
- 선택 후 이동 기능 구현 : 도형을 드래그하면 이전 좌표와 현재 좌표의 변위를 비교하여 도형의 좌표들을 업데이트합니다.
- 삭제 기능 구현 : 도형 객체 리스트의 맨 뒤 또는 선택된 도형을 `remove`합니다.

## 1. JFrame
수업시간에 자주 하던 것처럼, `public class`는 `JFrame`상속하도록 하고 생성자에서 사이즈 등의 초기 설정과 `JPanel`객체를 생성하여 추가하도록 하고, `main` 메소드에서 객체화하도록 하였습니다.

## 2. JPanel
실제로 버튼을 올리고 도형을 그릴 패널인 `MyPanel`은 `JPanel`을 상속합니다. 
또한 이 클래스에서 `MouseListener, MouseMotionListener, KeyListener`등의 리스너 인터페이스를 구현하고 자기자신을 이벤트관리자로 등록하도록 하였습니다.
따라서 모든 마우스와 키보드 이벤트는 해당 `MyPanel` 클래스에서 이벤트 리스너 메소드들을 `Override`하여 처리되게 됩니다.
- 멤버 변수 :
	여러 도형을 업캐스팅하여 저장하는 링크드리스트와, 토글버튼 객체들, `JColorChooser`와 `ButtonGroup`객체 등, 그리고 현재 선택된 색상, 버튼, 도형에 대한 정보 등을 필드로 유지합니다.
- 생성자 : 생성자에서는 다음과 같은 동작들을 수행합니다 :
	- `JColorChooser`의 객체를 생성하고 위치 등의 초기설정을 진행하며, `ChangeListener`를 람다식으로 구현하고 등록하여 동작을 정의합니다.
	- `initButtons` 메소드 호출 : 해당 메소드는 6개의 각기 다른 버튼 객체를 생성하고 업캐스팅하여 부모클래스의 배열로 저장하며, `ButtonGroup`에 등록하여 `JToggleButton`들을 그룹화하고, 각각의 `ItemListener`들을 등록합니다. 또한 `focus`가 버튼에 넘어가지 않도록 설정하여 KEY이벤트를 panel에서 받을 수 있도록 합니다.
	- 컴포넌트와 이벤트리스너들을 추가하고, KEY이벤트를 받을 수 있도록 focus를 설정합니다.
- 마우스 리스너 메소드 : 크게 도형을 그릴 때 또는 선택할 때로 나뉩니다. 
	- 도형을 그리는 경우 : 
		 - `press` : 새 객체를 생성합니다.
		 - `drag, release` : 생성한 객체의 도형의 끝점을 지정하고 `repaint`합니다.
	- 도형을 선택하는 경우 : 
		- `press` : 도형이 선택되었는지 여부를 판단합니다.
		- `drag, release` : 선택된 도형을 이동시킵니다.
- 키보드 리스너 메소드 : `BackSpace`가 눌리면 가장 최근에 그린 도형을, `Delete`가 눌리면 선택된 도형을 삭제합니다.

## 3. Button
버튼은 직선, 직사각형, 원형, 곡선, 색상선택, 도형선택, 이렇게 6가지의 종류가 존재합니다. 버튼들의 위치와 간격을 적당히 조정하고 싶으므로, 먼저 6가지의 다른 버튼 클래스를 만들기 전에 공통 부모 JButton클래스를 하나 만들었습니다.
- `MyButton` : `paintComponent`메소드를 오버라이드하여, 각각의 사이즈와 여백(margin)을 일괄적으로 통일시킵니다.
이제 이를 상속하여 6종류의 버튼 클래스를 작성하고, `paintComponent` 메소드를 오버라이드하여 버튼 내부의 그림을 다르게 그립니다.
- `LineButton` : 버튼 내부에 직선을 그립니다.
- `RectButton` : 버튼 내부에 직사각형을 그립니다.
- `CircleButton` : 버튼 내부에 원을 그립니다.
- `CurveButton` : 버튼 내부에 곡선을 그립니다. 예시 파일과 똑같이 하기 위하여, `setCurve`함수를 사용하여 최대한 똑같은 곡선을 그렸습니다.
- `ColorButton` : 현재 선택된 색상을 기억하고, 이 색상으로 속이 칠해진 직사각형을 그립니다.
- `MousePointerButton` : 화살표 모양을 그립니다. 이 때, 적당한 x,y좌표 배열을 생성하고 이를 `drawPolygon`메소드의 인자로 하여 다각형을 그립니다.

## 4. Shape (MyShape)
이제 도형 클래스를 작성하기 전에, 모든 도형클래스의 공통된 동작을 정의하는 부모클래스가 될 추상클래스인 `MyShape`를 작성합니다.
여기에 공통적으로 필요한 멤버 변수들을 두고, 공통 메소드들을 정의하고 작성해둔 뒤 자식클래스에서 이를 override하도록 합니다.
- 멤버 변수 : 
	- 도형의 시작 점(마우스 누른 지점)과 끝 점(마우스 뗀 지점) 위치 변수
	- 도형 이동 시 이동할 거리를 알기 위한 위치 변수
	- 도형 이동 시 이동할 변위를 나타내는 변수
	- 선택된 색상, 선택되엇는지 여부, 선택 후 이동중인지 여부 등.
- 생성자 : 마우스가 눌린 좌표를 도형의 시작점과 끝점으로 저장합니다.
- `draw` : 색상과 선 두께를 설정합니다.
- `mouseReleased, mouseDragged` : 마우스 `drag, release`이벤트 리스너에 대해 호출될 메소드입니다.
	- 도형을 선택하고 이동중인 경우 : 변위를 계산하고 그만큼 좌표를 업데이트합니다.
	- 도형을 그리는 중인 경우 : 도형의 끝 점 좌표를 설정합니다.
- `isClicked` : 도형이 선택되었는지 여부를 판단할 함수로, 각 도형들의 선택 판단은 도형마다 다르기 때문에 추상형으로 선언합니다.
- `setPressedPoint` : 도형이 움직이는 중으로 세팅하고, 눌린 좌표를 저장합니다.

이제 이 `MyShape` 클래스를 상속하여 4종류의 도형 클래스를 만들었습니다.
### 4-1. MyLine
직선을 그리는 것은 간단하지만, 선택 여부를 알아내는 것은 조금 생각해볼 필요가 있습니다. 제가 사용한 방법은 이렇습니다.
1. 클릭된 좌표인 (x,y)에 대해, 이 좌표로부터 직선의 시작 점 (x1,y1)까지의 거리($d_1$)와, 끝 점 (x2,y2)까지의 거리($d_2$)를 계산합니다. 
2. 직선의 시작 점과 끝 점 사이의 거리($d$)를 계산합니다.
3. $d$와 $d_1+d_2$를 비교합니다. 직선의 두께를 고려하여 적당한 오차범위 내에서 두 값이 일치하는지 확인합니다.
4. 이렇게만 할 경우 선의 두께로 인해 늘어난 양 끝 점의 부분이 잘 인식되지 않는 문제가 있습니다. 따라서, 양 끝점에 가상의 작은 원을 생각하고 이 내부까지 `true`로 정합니다.
이렇게 하여 선택 여부를 정하고, 도형이 선택되면 원본 도형의 밑에 더 두껍고 빨간색인 직선을 하나 더 그리면 테두리를 표현할 수 있습니다.
## 4-2. MyRect
간단히 `drawRect`, `fillRect` 메소드로 그릴 수 있으며, 선택 여부 또한 간단히 사각형 영역 내부를 확인하면 됩니다. 도형이 선택되면 `drawRect`의 색상만 변경합니다.
### 4-3. MyCircle
간단히 `drawOval`과 `fillOval` 메소드로 그릴 수 있지만, 이 메소드들은 기본적으로 (x1,y1)에서 (x2,y2)까지의 직사각형에 내접하는 타원을 그리는 메소드입니다. 
그러나 예시 파일처럼 누른 좌표가 원의 중심이, 드래그한 거리가 원의 반지름이 되도록 하려면 마치 좌표계를 변환하는 듯한 노력이 필요합니다.
따라서 다음과 같이 작성했습니다 : 
`drawOval((w >= 0 ? x1 : x2-w)-r, (h >= 0 ? y1 : y2-h)-r, 2*r, 2*r);`
선택 여부는 원의 중심 좌표에서 (x,y)까지의 거리가 원의 반지름보다 작은지 확인합니다.
### 4-3. MyCurve
곡선을 그리는 것은, 드래그하며 지나가는 모든 점들을 LinkedList로 유지하고, 이 모든 점들을 직선으로 연결합니다.
곡선의 선택 여부는, 마우스 클릭 좌표 (x,y)와 곡선의 모든 좌표들을 대조해봅니다. (x,y)가 곡선의 좌표 중 하나 근처(선의 두께에 따른 범위)에 해당한다면 선택으로 간주합니다.
도형이 선택되면 원본 곡선 밑에 더 두껍고 빨간색인 직선을 하나 더 그려 테두리를 표현합니다.

## 5. 구현 시 주의한 점
- `LinkedList`를 사용 시, 이 리스트의 원소를 수정하거나 역순으로 순회할 경우, 단순 for문으로 인덱스를 지정하여 원소에 접근하는 연산은 `LinkedList`에서 비효율적이므로 이를 조심했습니다.
	- 이 경우 단순 for문 대신, `iterator`를 이용하여 순회하였습니다.
- 키보드 이벤트를 받을 때는 `focus`라는 개념을 조심해야했습니다. 패널이 계속 focus를 가지고 있어야 입력을 처리할 수 있기 때문에, 버튼 등의 다른 컴포넌트에 focus가 넘어가지 않도록 하였습니다.
- 이외에도 JColorChooser에서 색상을 선택하면 JColorChooser가 닫히도록 하거나, 도형 선택 타이밍이 `press`인 점 등, 예시 파일과 비교하며 최대한 비슷하게 구현하였습니다.