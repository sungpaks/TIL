Thread : synchronization
억지 예시로... 데이터(money)를 읽는 것과 다시 쓰는 것 사이에 랜덤한 시간이 걸리게 해버리면
a가 읽고 딴짓하는동안, b가 읽고 써버리면?? => 경합상태에 빠지고, 

***스레드의 핵심은 메모리를 공유함***
읽기+쓰기를 하는 경우에 문제가 생기는데
읽고, 연산을 하고, 쓰기 직전까지 값에 변화가 생길 수 있음
다시말해, 화장실에 칸이 하나인데 한명이 들어가서 일을 보는 동안 100명이 와서 칸을 쓰려고 문을 열어버림
=> 들어가면 화장실 문을 잠가버리면 됨
들어갈 때 lock하고, 나갈 때 unlock하고
=> 그냥 함수 선언 앞에 키워드로 `synchronized`를 붙여버리면 됨 (또는 `synchronized(this) {}`로 감싼다)
근데 이러면? 나머지는 줄을 서니까 멀티스레딩이 멀티스레딩같지 않아지긴함
이 값이 진짜인가를 알아야함. : 읽고쓰는동안 값이 변경되면 안됨! 이렇게 중요하게 다뤄야할 부분을 ***critical section*** 이 사이는 중요해서 `synchronize`시켜야하는 것임 => Java에서 `critical section`임을 말해주는게 `synchronized (){}`인거임. 또는 다른데서는, `lock()` -> `unlock()`
또는 *critical section*대신 많이 쓰는 말이, `MutEx`또는 `mutual exclusive` 상호배제적? 두 차이는 찾아보세요~

`Thread.yield()` : 현재 나에게 할당된 시간이 남았어도, 다른 스레드에게 양보함 (이거있으면 synchronize문제가 생길 수 있음?)

producer-consumer 문제 : 버퍼링처럼, 수요보다 공급이 부족함 (조건이 부합하지 않으면 기다린다(`wait`), 조건이 이제 괜찮으면, 이제 준비됐다고 알린다 `notify`)
스레드가 돌다가 멈춘다(`wait`) -> 이제 돌아도 된다고 (외부에서) 알린다(`notify`)
- `notify` : 스레드 아무거나 하나 깨운다
- `notifyAll` : 스레드 전부 깨운다

Thread : Dynamics
스레드를 이용하면 매 순간마다 변화시킬 수 있다 (애니메이션처럼)
파티클시스템을 하나 보여드리겠습니다.

기본적으로 데이터가 있고, 그리는게 있고, 값을 변경시키는 세 가지 분류가 있음. => x,y 데이터 있고, 직사각형 그리는 paintComponent있고, 이제 값을 변경시키는 Thread를 추가
이렇게, **UPDATE**(값을 업데이트) -> **RESOLVE**(생기는 문제를 해결 : 업데이트된 값에 대한 반응 결과) -> **RENDER**(다시 `repaint`) 이 사이클을 도는 것을 ***GAME LOOP***
=> 예제 : 키보드 방향키 누르면 사각형 움직이게끔 
여기다가 Dynamics(운동학)을 좀 가미하면?
- 시간마다 값을 변화시키자 (위치, 속도, 가속도)
- 결과는 위치고, 가속도를 보통 정한다

[[C++ 멀티스레딩]]